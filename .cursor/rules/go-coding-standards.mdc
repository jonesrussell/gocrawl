# Go Coding Standards

## Code Style
- Follow Go standard formatting (use `go fmt` or `gofmt`)
- Use meaningful variable and function names
- Keep functions focused and single-purpose
- Use proper Go idioms and patterns

## Error Handling
- Always check and handle errors explicitly
- Use `if err != nil` pattern consistently
- Return errors up the call stack when appropriate
- Use `fmt.Errorf` with context for error wrapping

## Package Organization
- Keep packages focused and cohesive
- Use `internal/` for private packages
- Follow Go module conventions
- Use meaningful package names

## Testing
- Write tests for all public functions
- Use `testify` for assertions and mocking
- Follow Go testing conventions
- Use table-driven tests when appropriate

## Logging
- Use structured logging with Zap
- Include relevant context in log messages
- Use appropriate log levels (debug, info, warn, error)
- Avoid logging sensitive information

## Configuration
- Use Viper for configuration management
- Support environment variables and config files
- Validate configuration on startup
- Use sensible defaults

## Dependencies
- Use Go modules for dependency management
- Keep dependencies up to date
- Avoid unnecessary external dependencies
- Use `go mod tidy` to clean up dependencies

## Code Maintenance
- Regularly remove unused code (functions, types, variables)
- Use static analysis tools to identify dead code
- Remove helper functions that are only used by unused code
- Update comments when removing referenced code

## Refactoring and Code Quality
- Extract helper functions to eliminate code duplication
- Keep functions under 100 lines when possible
- Break down complex functions into smaller, focused functions
- Use helper functions to reduce duplication in type conversions
- Refactor when linters detect duplication or excessive function length

## Context Usage
- Use `CommandDeps` struct for explicit dependency passing (see command-architecture.mdc)
- DO NOT use `context.Value()` for dependency injection - use `common.NewCommandDeps()` factory
- Always check for errors when creating dependencies
- Use `cmd.Context()` for cancellation and timeouts only

## Dependency Injection
- Use `common.NewCommandDeps()` factory to get logger and config
- Use `common.CreateStorageClient()` for storage client creation
- Construct dependencies directly in command RunE functions
- DO NOT use FX modules for commands - FX was removed from command layer
- Keep dependency construction explicit and clear

## Command Implementation
- All commands MUST use `Command()` function pattern for registration
- Commands MUST use `common.NewCommandDeps()` to get dependencies
- Commands MUST use `common.CreateStorageClient()` for storage
- Use constants from `cmd/common/constants.go` instead of magic strings/numbers
- Use `atomic.Int32` directly for atomic operations (not `*int32`)
- Implement graceful shutdown for long-running commands
- See command-architecture.mdc for detailed patterns

## Parameter Naming
- Avoid shadowing imported package names with parameters
- Use shortened names when needed (e.g., `stor` instead of `storage`)
- Follow established naming conventions consistently

description:
globs:
alwaysApply: true
---
