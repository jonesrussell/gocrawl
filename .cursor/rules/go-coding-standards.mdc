# Go Coding Standards

## Code Style
- Follow Go standard formatting (use `go fmt` or `gofmt`)
- Use meaningful variable and function names
- Keep functions focused and single-purpose
- Use proper Go idioms and patterns

## Error Handling
- Always check and handle errors explicitly
- Use `if err != nil` pattern consistently
- Return errors up the call stack when appropriate
- Use `fmt.Errorf` with context for error wrapping

## Package Organization
- Keep packages focused and cohesive
- Use `internal/` for private packages
- Follow Go module conventions
- Use meaningful package names

## Testing
- Write tests for all public functions
- Use `testify` for assertions and mocking
- Follow Go testing conventions
- Use table-driven tests when appropriate

## Logging
- Use structured logging with Zap
- Include relevant context in log messages
- Use appropriate log levels (debug, info, warn, error)
- Avoid logging sensitive information

## Configuration
- Use Viper for configuration management
- Support environment variables and config files
- Validate configuration on startup
- Use sensible defaults

## Dependencies
- Use Go modules for dependency management
- Keep dependencies up to date
- Avoid unnecessary external dependencies
- Use `go mod tidy` to clean up dependencies

## Code Maintenance
- Regularly remove unused code (functions, types, variables)
- Use static analysis tools to identify dead code
- Remove helper functions that are only used by unused code
- Update comments when removing referenced code

## Refactoring and Code Quality
- Extract helper functions to eliminate code duplication
- Keep functions under 100 lines when possible
- Break down complex functions into smaller, focused functions
- Use helper functions to reduce duplication in type conversions
- Refactor when linters detect duplication or excessive function length

## Context Usage
- Use `CommandDeps` struct for explicit dependency passing (see command-architecture.mdc)
- DO NOT use `context.Value()` for dependency injection - use `common.NewCommandDeps()` factory
- Always check for errors when creating dependencies
- Use `cmd.Context()` for cancellation and timeouts only

## Dependency Injection
- Use `common.NewCommandDeps()` factory to get logger and config
- Use `common.CreateStorageClient()` for storage client creation
- Construct dependencies directly in command RunE functions
- DO NOT use FX modules for commands - FX was removed from command layer
- Keep dependency construction explicit and clear

## Command Implementation
- All commands MUST use `Command()` function pattern for registration
- Commands MUST use `common.NewCommandDeps()` to get dependencies
- Commands MUST use `common.CreateStorageClient()` for storage
- Use constants from `cmd/common/constants.go` instead of magic strings/numbers
- Use `atomic.Int32` directly for atomic operations (not `*int32`)
- Implement graceful shutdown for long-running commands
- See command-architecture.mdc for detailed patterns

## Parameter Naming
- Avoid shadowing imported package names with parameters
- Use shortened names when needed (e.g., `stor` instead of `storage`, `hostname` instead of `domain`)
- Follow established naming conventions consistently
- When importing `internal/domain`, avoid using variable name `domain` (use `hostname` for URL hostnames)

## Interface Organization
- **Interfaces MUST be defined in the same file as their implementation**
- Do NOT create separate `interface.go` files - consolidate interfaces into implementation files
- Use compile-time interface checks: `var _ InterfaceName = (*Implementation)(nil)`
- Pattern:
  ```go
  // In implementation file (e.g., internal/sources/sources.go)
  package sources
  
  // Interface defines the contract for source management
  type Interface interface {
      // ... methods ...
  }
  
  // Sources implements Interface
  type Sources struct {
      // ... fields ...
  }
  
  // Compile-time check
  var _ Interface = (*Sources)(nil)
  ```
- Exceptions: `internal/storage/types/interface.go` is kept separate to avoid circular dependencies

## Constants Organization
- **All shared constants MUST be defined in `internal/constants/constants.go`**
- Constants are organized by domain: HTTP/Server, Crawler, Storage, Logger, General
- Old constant files (e.g., `internal/common/constants.go`, `internal/crawler/constants.go`) may re-export constants for backward compatibility, but new constants should go in `internal/constants/`
- Use constants from `internal/constants` package instead of defining duplicates
- Pattern:
  ```go
  import "github.com/jonesrussell/gocrawl/internal/constants"
  
  // Use constants
  timeout := constants.DefaultRateLimit
  ```

## Domain Models
- **Use `internal/domain` package for all domain models** (not `internal/models`)
- Domain types: `domain.Article`, `domain.Page`, `domain.Content`, `domain.Job`
- Import pattern: `import "github.com/jonesrussell/gocrawl/internal/domain"`
- Type constants are prefixed with `Type` (e.g., `domain.TypeArticle`, `domain.TypePage`) to avoid conflicts with struct types

## Package Structure
- **Avoid catch-all packages** - each package should have a single, clear responsibility
- `internal/common/` should only contain truly shared utilities, not domain-specific code
- Source utilities are in `internal/sources/types/` (consolidated from `internal/sourceutils`)
- Do not create circular dependencies - use type packages when needed (`internal/storage/types/`)

description:
globs:
alwaysApply: true
---
