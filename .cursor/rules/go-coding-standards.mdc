# Go Coding Standards

## Code Style
- Follow Go standard formatting (use `go fmt` or `gofmt`)
- Use meaningful variable and function names
- Keep functions focused and single-purpose
- Use proper Go idioms and patterns

## Error Handling
- Always check and handle errors explicitly
- Use `if err != nil` pattern consistently
- Return errors up the call stack when appropriate
- Use `fmt.Errorf` with context for error wrapping

## Package Organization
- Keep packages focused and cohesive
- Use `internal/` for private packages
- Follow Go module conventions
- Use meaningful package names

## Testing
- Write tests for all public functions
- Use `testify` for assertions and mocking
- Follow Go testing conventions
- Use table-driven tests when appropriate

## Logging
- Use structured logging with Zap
- Include relevant context in log messages
- Use appropriate log levels (debug, info, warn, error)
- Avoid logging sensitive information

## Configuration
- Use Viper for configuration management
- Support environment variables and config files
- Validate configuration on startup
- Use sensible defaults

## Dependencies
- Use Go modules for dependency management
- Keep dependencies up to date
- Avoid unnecessary external dependencies
- Use `go mod tidy` to clean up dependencies

## Code Maintenance
- Regularly remove unused code (functions, types, variables)
- Use static analysis tools to identify dead code
- Remove helper functions that are only used by unused code
- Update comments when removing referenced code

## Refactoring and Code Quality
- Extract helper functions to eliminate code duplication
- Keep functions under 100 lines when possible
- Break down complex functions into smaller, focused functions
- Use helper functions to reduce duplication in type conversions
- Refactor when linters detect duplication or excessive function length

## Context Usage
- Use `CommandContext` for type-safe dependency passing (see command-architecture.mdc)
- DO NOT use `context.Value()` with individual keys - use `CommandContext` instead
- Always check for errors when retrieving dependencies from context
- Propagate context properly to all subcommands

## FX (Uber FX) Usage
- Use FX modules for internal package dependency injection
- DO NOT create new `fx.New()` apps in command RunE functions
- Construct dependencies directly in commands
- Keep FX modules minimal - only include what's needed
- Avoid duplicate module inclusions (causes "already provided" errors)

## Command Implementation
- All commands MUST use `Command()` function pattern for registration
- Commands MUST construct dependencies directly in RunE functions
- Use helper functions for common dependency construction patterns
- Implement graceful shutdown for long-running commands
- See command-architecture.mdc for detailed patterns

description:
globs:
alwaysApply: true
---
